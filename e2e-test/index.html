<!DOCTYPE html>
<html>
<head>
  <title>tmax E2E Test</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.min.css" />
  <style>
    body { margin: 0; background: #1e1e2e; color: #cdd6f4; font-family: monospace; }
    #controls { padding: 12px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    #controls button { padding: 6px 14px; background: #313244; color: #cdd6f4; border: 1px solid #45475a; border-radius: 4px; cursor: pointer; }
    #controls button:hover { background: #45475a; }
    #controls button.active { background: #89b4fa; color: #1e1e2e; }
    #status { padding: 4px 12px; font-size: 13px; }
    .connected { color: #a6e3a1; }
    .disconnected { color: #f38ba8; }
    .info { color: #89b4fa; }
    #terminal-container { padding: 0 12px 12px; }
    #sessions { padding: 0 12px; font-size: 13px; }
    #sessions table { border-collapse: collapse; width: 100%; }
    #sessions th, #sessions td { text-align: left; padding: 4px 8px; border-bottom: 1px solid #313244; }
    #log { padding: 8px 12px; font-size: 12px; max-height: 150px; overflow-y: auto; background: #11111b; margin: 8px 12px; border-radius: 4px; }
    #log div { padding: 1px 0; }
  </style>
</head>
<body>
  <div id="controls">
    <button onclick="fetchSessions()">Refresh Sessions</button>
    <button onclick="createSession()">Create Session (/bin/bash)</button>
    <button id="connectBtn" onclick="toggleWs()">Connect WS</button>
    <span>Session ID: <input id="sessionId" size="40" placeholder="paste session id here" /></span>
    <button onclick="subscribeSession()">Subscribe</button>
  </div>
  <div id="status" class="disconnected">Disconnected</div>
  <div id="sessions"></div>
  <div id="terminal-container"></div>
  <div id="log"></div>

  <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.min.js"></script>
  <script>
    const WEB_URL = 'http://127.0.0.1:7860';
    const WS_URL = 'ws://127.0.0.1:7860/ws';

    let ws = null;
    let term = null;
    let fitAddon = null;
    let subscribedSession = null;

    // Initialize xterm.js
    function initTerminal() {
      term = new window.Terminal({
        cursorBlink: true,
        fontSize: 14,
        theme: {
          background: '#1e1e2e',
          foreground: '#cdd6f4',
          cursor: '#f5e0dc',
        }
      });
      fitAddon = new window.FitAddon.FitAddon();
      term.loadAddon(fitAddon);
      term.open(document.getElementById('terminal-container'));
      fitAddon.fit();
      term.writeln('\\x1b[90m--- tmax E2E test terminal ---\\x1b[0m');

      // Forward keyboard input to WS
      term.onData(data => {
        if (ws && ws.readyState === WebSocket.OPEN && subscribedSession) {
          // Send as binary frame: [sid_len][sid][data]
          const sidBytes = new TextEncoder().encode(subscribedSession);
          const dataBytes = new TextEncoder().encode(data);
          const frame = new Uint8Array(1 + sidBytes.length + dataBytes.length);
          frame[0] = sidBytes.length;
          frame.set(sidBytes, 1);
          frame.set(dataBytes, 1 + sidBytes.length);
          ws.send(frame.buffer);
        }
      });

      window.addEventListener('resize', () => fitAddon && fitAddon.fit());
    }

    function log(msg, cls = '') {
      const el = document.getElementById('log');
      const d = document.createElement('div');
      if (cls) d.className = cls;
      d.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      el.appendChild(d);
      el.scrollTop = el.scrollHeight;
    }

    function setStatus(msg, cls) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = cls;
    }

    // REST: fetch sessions
    async function fetchSessions() {
      try {
        const resp = await fetch(`${WEB_URL}/api/sessions`);
        const data = await resp.json();
        log(`Fetched ${data.length} sessions`, 'info');
        renderSessions(data);
      } catch (e) {
        log(`Fetch failed: ${e.message}`, 'disconnected');
      }
    }

    function renderSessions(sessions) {
      const el = document.getElementById('sessions');
      if (sessions.length === 0) {
        el.innerHTML = '<p style="color:#6c7086">No sessions. Create one first.</p>';
        return;
      }
      let html = '<table><tr><th>ID</th><th>Label</th><th>Exec</th><th>Status</th><th>Actions</th></tr>';
      for (const s of sessions) {
        const status = s.exited ? `exited(${s.exit_code})` : 'running';
        html += `<tr>
          <td style="font-size:11px">${s.id}</td>
          <td>${s.label || '-'}</td>
          <td>${s.exec}</td>
          <td>${status}</td>
          <td><button onclick="document.getElementById('sessionId').value='${s.id}';subscribeSession()">Attach</button></td>
        </tr>`;
      }
      html += '</table>';
      el.innerHTML = html;
    }

    // Create a session via CLI (REST doesn't have create endpoint yet)
    async function createSession() {
      log('Creating session... (use CLI: cargo run -p tmax-cli -- new --shell)', 'info');
      alert('Run in another terminal:\\n\\ncargo run -p tmax-cli -- new --shell\\n\\nThen click Refresh Sessions.');
    }

    // WebSocket
    function toggleWs() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
        return;
      }
      connectWs();
    }

    function connectWs() {
      ws = new WebSocket(WS_URL);
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        setStatus('WebSocket Connected', 'connected');
        log('WebSocket connected', 'connected');
        document.getElementById('connectBtn').classList.add('active');
      };

      ws.onclose = () => {
        setStatus('Disconnected', 'disconnected');
        log('WebSocket disconnected', 'disconnected');
        document.getElementById('connectBtn').classList.remove('active');
        subscribedSession = null;
      };

      ws.onerror = (e) => {
        log(`WebSocket error: ${e}`, 'disconnected');
      };

      ws.onmessage = (event) => {
        if (event.data instanceof ArrayBuffer) {
          // Binary frame: PTY output
          const bytes = new Uint8Array(event.data);
          const sidLen = bytes[0];
          const sid = new TextDecoder().decode(bytes.slice(1, 1 + sidLen));
          const data = bytes.slice(1 + sidLen);
          // Write raw PTY bytes to xterm
          term.write(data);
        } else {
          // Text frame: JSON control message
          try {
            const msg = JSON.parse(event.data);
            log(`WS msg: ${JSON.stringify(msg)}`, 'info');
            if (msg.type === 'subscribed') {
              log(`Subscribed to ${msg.session_id} (catchup: ${msg.catchup_count})`, 'connected');
            } else if (msg.type === 'error') {
              log(`Error: ${msg.message}`, 'disconnected');
            } else if (msg.type === 'event') {
              // Non-output events
              log(`Event: ${JSON.stringify(msg)}`, 'info');
            }
          } catch (e) {
            log(`Parse error: ${e}`, 'disconnected');
          }
        }
      };
    }

    function subscribeSession() {
      const sid = document.getElementById('sessionId').value.trim();
      if (!sid) { alert('Enter a session ID'); return; }
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        connectWs();
        // Wait for connection then subscribe
        setTimeout(() => subscribeSession(), 500);
        return;
      }
      subscribedSession = sid;
      term.clear();
      term.writeln(`\\x1b[90m--- Subscribing to ${sid} ---\\x1b[0m`);
      ws.send(JSON.stringify({
        action: 'subscribe',
        session_id: sid,
        mode: 'edit',
        last_seq: null
      }));

      // Send resize
      const dims = fitAddon.proposeDimensions();
      if (dims) {
        ws.send(JSON.stringify({
          action: 'resize',
          session_id: sid,
          cols: dims.cols,
          rows: dims.rows
        }));
      }
    }

    // Init
    initTerminal();
    fetchSessions();
  </script>
</body>
</html>
